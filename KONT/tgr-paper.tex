%

% 2018 7. Разработка ядра логического вывода конфигураций каркасов функциональных блоков информационной системы по комплексной модели MDA.
% 2019 7. Разработка технологий и инструментальных средств создания размеченных документов на основе интерпретации комплексной платформонезависимой модели информационной системы.
% 2020 7. Разработка специализированного интерпретатора платформонезависимой модели, ориентированного на поддержку современных средств разработки интернет-приложений, функционирующих в среде Linked Open Data.

\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
%\usepackage[T1]{fontenc}
%\usepackage[utf8]{inputenc}
\usepackage{luatextra}
\usepackage{currvita}
\usepackage{minted}
%\usepackage{ulem}
%\usepackage[]{geometry}
% \usepackage[a4paper,margin=2cm]{geometry}
\usepackage{multicol}
\usemintedstyle{bw}
\usepackage{enumitem}
%\usepackage{indentfirst}
\setminted{fontsize=\small}

\providecommand{\sout}[1]{}



% *** CITATION PACKAGES ***
%
%\renewcommand\cite[1]{[[#1]]}

\usepackage{hyperref}
\hypersetup{
    % bookmarks=true,         % show bookmarks bar?
    unicode=true,          % non-Latin characters in Acrobat’s bookmarks
    pdftoolbar=true,        % show Acrobat’s toolbar?
    pdfmenubar=true,        % show Acrobat’s menu?
    pdffitwindow=false,     % window fit to page when opened
    pdfstartview={FitH},    % fits the width of the page to the window
    %pdftitle={},    % title
    %pdfauthor={Author},     % author
    %pdfsubject={Subject},   % subject of the document
    %pdfcreator={Creator},   % creator of the document
    %pdfproducer={Producer}, % producer of the document
    %pdfkeywords={keyword1, key2, key3}, % list of keywords
    %pdfnewwindow=true,      % links in new PDF window
    colorlinks=true,       % false: boxed links; true: colored links
    linkcolor=black,          % color of internal links (change box color with linkbordercolor)
    citecolor=black,        % color of links to bibliography
    filecolor=black,      % color of file links
    urlcolor=black,           % color of external links
    final=true
  }

\setmainfont{Times New Roman}

\begin{document}
\title{Object Representation of MDA Transformation by Means of Logical Inference\thanks{The results are obtained with the partial support of the various projects: Russian Foundation for Basic Research, grant 18--07--0075,
Russian Science Foundation, grant 18--71--10001,
Irkutsk scientific center of SB RAS, grant 4.2.}}

% \titlerunning{Implementation of a QMS with MDA}

\author{
\IEEEauthorblockN{Evgeny Cherkashin, Alexey Shigarov, Viacheslav Paramonov}
\IEEEauthorblockA{\textit{Matrosov Institute for System Dynamics and Control Theory of SB RAS,} \\
 \textit{Irkutsk Scientific Center of SB RAS} \\ 134 Lermontov Street, Irkutsk, 664033, Russia\\\{eugeneai,shig,slv\}@icc.ru}
}

% \tocauthor{Evgeny Cherkashin, Alexey Shigarov, Viacheslav Paramonov, Ljubica Kazi}

% \authorrunning{Evgeny Cherkashin, Alexey Shigarov \emph{et al.}}

% \email{\{eugeneai,shig,slv\}@icc.ru, ljubica.kazi@gmail.com}}

\maketitle

\begin{abstract} % 70-150 words
  The problem of software modeling having various models as sources and its transformation based on logical inference is considered.  Source models are converted into graphs of RDF (Resource Description Framework) and then processed with knowledge based system organized in a network of objects.  Various notation can be used to represent models, such as UML, SysML, CMMN, BPMN2.0, as well as RDF graphs and analyzed source code, having implemented a corresponding converter.  The objects are represented in the LogTalk programming language.  Objects query graphs and other objects implementing a scenario of a software system (most frequently, information system) carcass synthesis within Model Driven Architecture (MDA) paradigm.

  Usage of such kind of MDA transaction approach allows us to develop information system carcasses on the level of abstract models, involve various sources of model data in the transformation, define and structuring conversion knowledge as objects.  An example of a dataflow environment synthesis encapsulating Mothur library for new generation sequencing is presented.
\end{abstract}

\begin{IEEEkeywords}
model driven architecture, logical inference, resource description framework, LogTalk
\end{IEEEkeywords}

\section{Introduction}
\label{sec:intro}

% The simplest approach to a system improvement consists of the repetitive execution of the following steps over a level of organization under reingeneering:
% \begin{enumerate}
% \item imaging the target state of the system (future),
% \item comparison with the present state,
% \item assessment of the deviations from the target state,
% \item planning set of actions for reaching the target state,
% \item performing the planned set of actions,
% \item control of the achieving the target state by, e.g., checking the set of target criteria.
% \end{enumerate}

% Business process (BP) reingeneering usually starts from a technical audit (TA), the process of a system analysis of an organization structure, its problems and resources \cite{techaudit}.  The result of the TA is set of text documents describing the present state of the organization and its BPs on the various levels (social, administrative, technical, and physical).  The set comprises specifications of organization structure, BP models (AS-IS, TO-BE), target state requirements and restrictions, etc.

% [[Specification structure]]

% [[[Point of views: people resources, marketing, technology, IT, finance]]]

% [[Gathering information]]

% There are three general creative roles of stakeholders involved in the improvement and revealed during TA: \emph{problem owner}, \emph{knowledge owner}, and \emph{problem solver}.  Problem owner is the agent (person), who recognizes the problems in the current state.  This role describes future target state as a ranged list of \emph{requirements} and \emph{restrictions}.  Knowledge owner describes the states in technical terms of the problem domain.  The description contains structure of BPs, their sequences, parameters, causal relationship, control processes, etc.  Problem solver searches and devices a problem solution, relying on a problem solving methodology, respecting interests of the problem owner, and information acquired from knowledge owner.

% [[[How we can represent specifications as IT SUBSYSTEM of an existing system? dring the process of improvement]]]

% [[[Application of the nowadays modeling notations in specifications for the low levels]]]
% .....MOD to be improved with more expressive but complex notions of SysML (System Markup Language), BPMN--2.0 (Business Process Modeling Notation) and CMMN (Case Management Modeling Notation).  SysML used to describe organizational and administrative structures in higher degree of abstraction with respect to UML2, which is used at administrative and technical levels, and in the same time to be more detailed.  The usage of these modeling notation will allow to describe the present organizational structure more formally and precisely as a Computational Independent Model (CIM) and Platform Independent Model (PSM) of MDA paradigm, resulting the bridge between specifications and IT resource under development.

% Heaving described BPs structure and flows of an organization in the formal detailed multilevel form in SysML, we could construct an environment of a permanent IS research and development.  At the first stage, a most simple case is being realized: the description could be converted into check lists controlling conditions of business process starting and ending points. The second stage of implementation is the automation of planning after reaching a checked condition.  The third stage is to organize data processing according to the synthesized plan.  In the long run a refined specification description is being integrated with already used software.  All the stages are accompanied with a lot of useful information to be accumulated, forming the quality measurement, knowledge and analysis basis \cite{aiowa}.

% TOO MANY GOALS AND TOO COMPLEX SOFTWARE - SHOULD BE PRESENTED AS A COMPONENT DIAGRAM WHICH CAPTURES THE IDEA AND SERVES AS A BASIS FOR THE LONG-TERM DEVELOPMENT.THE IDEA WRITTEN THIS WAY IS TOO WIDE AND MISTY.

[[Speak about complexity of IS. One of solution is rising automation level to design. CASE and their closeness of ``standard'' technologies, disallowing usage in, e.g., web IS, special cases. Working with lazy IT customer (uncertainties of its requirements)]]

[[Problem - develop a expressive means for transformation implementation, allowing known practice of object-oriented programming within implementation of the transformations based on knowledge application, allowing us to use various model sources describing IS from various aspects (structural, dynamic, organizational, integration with other ISs, etc.).  Low popularity of generative approach in web development due to high flexibility of the frameworks and absence of transformation implementation techniques ``consuming and adapting previous experience'' expressed in transformational libraries, which are also absent.]]

The most examined transformational approach of code generation is Model Driven Architecture.
[[MDA description, PSM, sources, PIM, CIM (vice-versa). Then notion of transformation CIM->PIM->PSM->sources and data]]

[[First - data sources, show which models can be used in each levels. Speak about that there is a lot of useful data, already well enough structured and represented as ontologies and ...pedias, which could be used in the synthesis as auxiliary data sources.]]

The \emph{object} of the research is the development of a tradition technology \cite{} of expression of process structure of an organization in above mentioned notations (SysML, BPMN-2.0, CMMN, UML) and conversions of the description into subsystems of a complex information system supporting the BP reingeneering processes. The \emph{subject} we consider in this paper is to describe tools and techniques of complex model definition and its interpretation as a MDA transformations.

\section{Architecture of MDA tools}

% (here we speak about how to convert BPMN, SysML and CMMN models into carcass of an Inform. System... various stages of processing, including input....)

The architecture of the software development tools is based on the provision of uniformity of the transformation rules language and predicate input data representation.  That's why we require either to store all the input model data in Semantic Web graphs of ontologies, or provide an interface representing the source model as the ontology graph.  The ontologies could be served as RDF--files of triples or with servers having SPARQL endpoints.  A general architecture of the development tools is presented in Fig.~\ref{fig:archi}.

\begin{figure}[htb]
  \centering
   \includegraphics[width=1\linewidth]{pics/architecture-mda-lod-ext.pdf}
  \caption{Architecture of MDA tools}
  \label{fig:archi}
\end{figure}

The MDA tools consists of the following main components:
\begin{itemize}
\item domain model server (2), which stores and retrieve model data as RDF triples;
\item transformation MDA engine (1), which queries data from the domain server and auxiliary from other SPARQL compliant ontology servers (4);
\item the main model data sources, representing CIM (3) and PIM (6);
\item indexing engine (5), which provides persistent utility means for text data storage and text processing interfaces.
\end{itemize}

All components interact by means of network protocols and use utf-8 encoded HTML, TXT, XML and JSON formats for data representation, which are expressive enough and easily debugged.  Inference engines also support SPARQL protocol for issuing subqueries.

The kernel of the system is MDA Tool, which is a set of transformational modules (T--Modules). Each of T--Module in a general case is a parameterized LogTalk object.  The object queries the Server of domain models, which is built on the base of ClioPatria \cite{Clio}, other objects and other Ontology servers for structural patterns.  These patterns are analyzed and the results are stored as the objects states, \emph{i.e.} cached.  The states of the object represent Platform Specific Model (PSM), which is translated into source code and initial data.  Input structures of CIM and PIM models are converted into graphs with converter adapters.  For example in Fig.~\ref{fig:archi} CIM (3) drawn in Modelio \cite{modelio} is converted to triples with a special module ``XMI to RDF converter''.  Similar converter is realized for PIM represented in UML.  This approach makes the input stage modular, and, consequently, easier extensible with new model types.

%IF WE EMPHASIZE SYSML, HOW IS IT RELATED TO SEMANTIC WEB TRIPLETS? THIS SHOULD BE EXPLAINED.

There are number of partially structured data sources related to terms reflecting common objects.  For example, \texttt{DBPedia.org} contains naming in various languages, as well as relations, of the entities represented in Wikipedia.  This information can be used to describe user interface properties of the program objects, and referred by URI's from devised models.  For example, we can use DBPedia for constructing \texttt{title} and \texttt{placeholder} attributes of an input widget, together with its label name text in user's locale and a help description.

% Some UML-structures (OCL) and relations may be interpreted constructively as methods of objects: events, handlers, subscribers, database triggers and selectors (lookups widgets).

\section{RDF representation of the models}
\label{sec:rdf-repr}

The past 20 years of unhurried Semantic Web (SW) technologies development formed descriptions of commonly used domains and represented them as standard W3C approved ontologies.  It enables system designer and programmer to use globally identified resource references (URI), and ontology representation standards (RDF, RDFa, TTL, etc.), which are implemented in various programming environments as libraries.  This results in a globally approved (in various software projects) knowledge and data base, the common foundation of a domain description.  This is why, we decided to represent the source model data in the SW framework too, efficiently enriching the existing knowledge with a specific domains.  From other hand side, converting the complex tree-like structures used for model representation to set of triples, i.e. facts for inference machine, enables us to use Prolog based engines for transformation definition.

In order to meet SW requirements, each model should be identified with a global URI, and in addition, its prefix could be defined.  All relations and attributes must be expressed in a SW ontology, which should preferably be a standard one and have a publicly accessible formal definition.  The entity names and their relation expressed with the source notation must be convertible to the RDF definition upon request from transformation engine.  [[what else must be said about the representation, e.g. details of the transformation engine...]]

\subsection{Entity denotation}
\label{sec:ent-def}

Entity identification and naming in RDF representation have various aspects.  An entity (or a relation) exists if it is defined or referred with its URI.  In addition, an entity can be named,  i.e. for its URI is defined a naming relation, e.g., \texttt{dc:title} or \texttt{rdfs:label}.  The relation \texttt{rdfs:range} refers to a \texttt{literal} string with a corresponding name in a natural language (defined by an attribute).  So, each structure object or a relation in model notation must have a corresponding notation in an model representation ontology.

As the entities have global identification, their mentioning in different models denote the same object, e.g. in a BPMN diagram, a record object could be created of a type defined in an UML Class Diagram.  In this case the type is double referenced object of the software model.  The references of an entity of a model from another model can be done as RDF names of a form \texttt{<prefix>:<identifier>}, where \texttt{<prefix>} is the prefix of the model, where \texttt{<identifier>} is defined.  Most UML and other modeling software do not restrict names of the identifiers, the restrictions are applied with a transformation tools.

[[ What else it is necessary to describe here?]]

\subsection{Model extensions}
\label{sec:mod-ext}

A flexible modeling tools also allow designer to extend a notation of a model (metamodel).  For example, all UML diagrams support \emph{stereotypes}, \emph{tag values}, and \emph{object constrains}.  Firstly, stereotypes denoted a kind of a described object (it can be assigned to any entity or relation), e.g., in a Class Diagram stereotypes is used to define the kind of a class.  If a class box is assigned standard \texttt{<<interface>>} stereotype then it is an interface definition.  By default all classes are standard \texttt{<<class>>}-es.  The same is used to describe relations between use cases in Use Case diagram.  A use case can \texttt{<<include>>} another one or be \texttt{<<extend>>}-ed with another use case.  User-defined stereotypes can express various aspects of classes, e.g., we can define the storage class as an ORM\footnote{Object relation mapping} of a class by \texttt{<<RDBMSRecord>>} stereotype.  In this case, class is added to set of classes describing a relation database records, all relations between such classes are interpreted as rational (one--to--one, one--to--many, many--to--many, mandatory, etc.) relations.  One entity can be assigned many stereotypes.

Tag values allow one to associate a string value identified by a string key, which are somehow interpreted with a traditional procedure.  For example, the easy way of providing of an interface label name for an object \texttt{age} field in a class defined in a Class Diagram is an association the field with tag name \texttt{interface-label-name} as \texttt{''Age''} string.  Using RDF, we can change the tag name to \texttt{dc:title} and value can be interpreted as URI, e.g. to a \texttt{DBPedia} object.

The usage experience of stereotypes and tag values resulted in recognition of the fact, that assigning a stereotype usually implies definition of the same set of tag values.  UML standard of version 2.4 fixed this observation, allowing formal definition the set of tag values for user-defined stereotypes.  Special user interfaces were developed to control assignment a stereotype to an entity.  As stereotype does not provide a value in its association, table name for \texttt{<<RDBMSRecord>>} an optional tag value can be defined for this purpose, e.g., \texttt{rdbms:table-name}.  UML-2.4 explicit stereotype descriptions is a powerful tool for attributing entities with additional information.

% [[[Resume of some kind]]]

\subsection{Other sources of model data}
\label{sec:other-models}

When implementing complex systems, which are composed from existing subsystems, these subsystem's specifications can be additional sources of model data.  For example, in our project \cite{bit2019}, the main PIM model is extracted from source code of the original library Mothur and converted to TTL (turtle) representation.  This approach requires one-time programming for adaptation of the sources, but for each new version of the library we can obtain new version of the PSM without additional analysis.  Formal rules of the source code analysis ad interpretation as PSM can also assist in finding errors in the source code.

[[PSM libraries....???]]


\section{Related works}

The most widely used technology of model transformation is ATL (ATLAS Transformation Language) \cite{atl} and its predecessor QVT, an OMG standard \cite{QVT}.  The language and its engine supports conversion from one XMI model to another one in the same XMI format.  The language structures describe recognition of properties of compositions of the source model and direct construction of new structures in the target model.

Similar to ATL, Transformation Model Representation Language (TMRL) is developed in \cite{nikita} but oriented on visual representation of a knowledge base with following conversion in various production rules in CLIPS and OWL.  The visual presentation of transforming rules are used also in \cite{GT}.  In \cite{azis}, ATL is used to transform Computational Independent Model (CIM) represented as BPMN diagram into set of UML diagrams, defining PIM. Paper \cite{Rhazali} proposes a model transformation CIM to PIM for web-applications, where CIM is represented with State and Use case UML-Diagrams logically connected with ATL rules.  In \cite{Hamid} is proposed an evaluation of security aspects of distributed applications using MDA description; the evaluation is implemented a logical inference over the MDA synthesized logical security models. The paper \cite{Zdun} is considered a highly decoupled distributed event-driven application environment, whose design and functioning is dynamically controlled by its three-level DSL description and MDA transformations, which support change propagation.

Paper \cite{Malki} presents a practical approach with four-level ATL-description from HTML-page to a LOD structure (via stage of an MDA PIM). In \cite{uml2owl}, a converter of UML package structures represented in XMI was developed as a XSLT transformation. A wide overview of Western approaches to program transformation is given in \cite{Dama,Dama2}, a transformation language PROMOL is suggested as well as its logical semantics. OMG proposed ODM standard \cite{odmprof} for knowledge modeling.  A Visual Ontology Modeler \cite{odnext} is being developed for building and verifying OWL ontologies for ODM~1.0, as well as in the reverse direction, ontologies are represented as UML Class Diagrams \cite{odmvis}.

An XML based specifications are used in representing metadata about web services, WSDL \cite{wsdl}, and the WS-BPEL language \cite{wsbpel} for describing orchestration of web services within execution of an instance of a business process.  The idea of the language is to describe complex systems down to Web Services units, their internal and external structure and behavior, as well as services interaction in the script instance.

Thus, the majority of the presented techniques are closed with respect of XMI file format: the source data and the result of the transaction are represented in it, and it goes beyond only on the stage of the source code generation.  Our approach allows one to use other sources (not being presented in XMI) of model information, as well as general purpose libraries in implementation of the transformation engine.  Usage of object-oriented logical language LogTalk allows us powerfully structuring and manipulate knowledge base by means of the object encapsulation, inheritance, and composition.

% \subsection{Ontology Usage in Model Representation}
% \label{sec:use-onto}

% SysML is the dedicated system-level UML-based notation proposed by the OMG. In research \cite{raslan} system design productivity is addressed as one of the main challenges. Some suggested approaches are increasing the level of abstraction and automation, as well as producing executable specifications. In \cite{natale}, model driven development is used for the construction of complex embedded systems integrating software and firmware. A SysML system model is devised according to the platform-based design paradigm, in which a functional model of the system is paired to a model of the execution platform. Subsystems are refined as Simulink models or hand-coded in C++.

% The SysML standard is attracting more attention of hardware designers as UML and SysML have been used to automatically generate an HDL code written in SystemC, Verilog and VHDL. In \cite{boute}, contrarily to the existing works, authors propose the new reverse engineering approach to generate SysML definition of block and internal block diagrams from VHDL code. Code generation is done on the basis of a set of well-defined mapping rules between SysML and VHDL concepts.

% UML profiles like SysML and MARTE have been a major research topic in electronic system design, but are mainly applied for specification and analysis in early design phases.  Research \cite{mish} addresses the problem of the High-Level Synthesis (HLS), \emph{i.e.} physical implementation aspect of electronic systems, which need diversity of design models and levels of abstraction.  To overcome the conflict between a higher degree of abstraction and necessary details for further synthesis, modular interfaces are introduced as object-oriented synthesizable technique. In \cite{mish}, SysML is used as an adequate modeling language for modular interfaces and C/C++/SystemC-based HLS. Authors extended SysML with annotations for synthesizable SystemC and high-level synthesis constraints and implemented a code generation scheme to achieve design flow automation. They used SysML editor Artisan Studio with industrial case study to demonstrate the applicability of SysML as a front-end for HLS.

% In \cite{tom16} UML/SysML is used to model avionics.  The implementation language is C\# with using libXML for XMI import and processing.  Generated objects represent each syntactic element (\texttt{struct}, \texttt{enum}, function, \emph{etc.}), which represents the target source code.  Authors implemented only State Machine diagram transformation.

% % \cite{fab} % the lost reference

% Some experience of representing document flows are obtained by commercial software vendors developing Directum, Documentum systems automatizing Russian municipal institutions and state corporations.  Directum uses SysML state--like block diagrams to define flow of documents and the ISBL object-oriented language to express sophisticated behavior.

% % NOT ONLY THIS, THERE IS MORE NEEDED IN THE RELATED WORK SECTION: BUSINESS PROCESS MANAGEMENT SYSTEMS, BUSINESS RULES MANAGEMENT SYSTEMS, WORKFLOW MANAGEMENT SYSTEMS.

% In our research we focus on representation of ISO 9001 entities in SysML and other DSLs translatable to RDF, and the MDA transformation logical inference representable as LogTalk objects.

% \section{SysML representation of QMS}

% QMS is represented in SysML with nine diagrams \cite{sysmlpres}.  QMS requirements is represented with new (with respect to UML) \emph{Requirement Diagram}, describing stated structural and logical constraints. Structural aspects are represented with following UML2 diagrams:
% \begin{itemize}
% \item \emph{Block Definition Diagram} decomposes structure of activities, attributes and objects on elements;
% \item \emph{Internal Block Diagram} models interaction of the decomposed elements and their data flow; its descendant new \emph{Parametric Diagram} describes model of block attribute relationships;
% \item \emph{Package Diagram} organizes models in packages in various ways.
% \end{itemize}
% Behavioral aspect of a QMS is expressed with UML2
% \begin{itemize}
% \item \emph{Use Case Diagram}, which expresses functions of the system and their mutual relationships;
% \item \emph{State Machine Diagram} defines the states of the blocks and transitions between the states;
% \item \emph{Sequence Diagram} describes the order of messages between blocks and actors;
% \item \emph{Activity Diagram} represents computational process of converting data enclosed in blocks.
% \end{itemize}

% BPMN2.0 diagram is used to describe imperative procedures, it is very expressive diagram representing functions and involving agents, together with their relationships.  CMMN represents declarative aspects of the QMS especially data structures, processing stages, events and check points (milestones).  Adding BPMN2.0 and CMMN diagrams to SysML diagram set creates a redundancy, but in the same time it allows one to use more rich tool set for QMS modeling.

\section{Technique of Transformation Implementation}
\label{sec:tech-imp}

The main idea behind implementation of transformation engine is an usage of a logical programming language adapted to meet the following constraints:
\begin{itemize}
\item transformation system must support multiple sources of model data,
\item the language must be expressive, at least first-order language,
\item transformation is represented as rules (patterns),
\item rules should be encapsulated in objects,
\item objects should send each other messages with results of inference,
\item objects should be a way of transformation configuration and scenario description,
\item refining existing rule set (knowledge base) by adding, deleting and replacing,
\item composition knowledge bases out of pieces,
\item there should be a way of easy expression of RDF entities.
\end{itemize}

These constraints are meet if we will use SWI-Prolog with LogTalk macro package and RDF library.  The multiplicity of source data is archived with conversion of source structures to RDF triple sets, and object orientation of transformation representation: objects are encapsulations of model data.  The LogTalk objects encapsulate Prolog first-order language rules as methods.  Each object is respected as a knowledge base as encapsulated rules.  Objects can be inherited (as prototypes or classes), parameterized, and composed with \emph{categories}.  In inheritance, methods can be reprogrammed implementing refining original knowledge set.  Configurations are implemented as a prototyping hierarchies: in inheritance, a configuration are refined by replacing and adding new values.  Scenarios are implemented as an ordered sets of methods.  Finally, SWI-Prolog has a good LogTalk compatible RDF library strongly tied to the language itself.  The library represents RDF entities in a W3C compliant way.

[[Rule representation in Prolog]]

% Existing popular approaches of implementing Platform independent model (PIM) to Platform specific model (PSM) transformation, taking into account the runtime and other implementation platform features.  The first approach is model-to-model transformation with a model transformation language, such as QVT-X, ATL, \emph{etc.}  In this case PIM and resulting PSM are represented as XMI files.  Model transformation language rules recognizes structures in PIM and construct structures of PSM, having account various \texttt{boolean} conditions calculated with helper rules. The second variant of transformation is realized with Domain Specific Language (DSL) infrastructure \cite{stratego}.  The transformation procedure is presented as translation of one DSL instance, \emph{i.e.} PIM, to an instance in another language.


%Resume
Our approach is based on common known in AI tools, but requires additional programming of libraries of model transaction objects.

\subsection{LogTalk as transformation engine}
\label{sec:logtalk-engine}

The direct way of a transformation implementation is to use \textsc{Prolog} or a functional language, and we use \textsc{Logtalk}, a macro package of Prolog.  The main advantage of the language usage is knowledge structuring thanks to its object-orientation.  Objects are used for representation of the source PIM model and the resulting PIM structures as well as source code generators.  Moreover, the transformation rules are easily integrated with libraries processing LOD and LOD warehouses.


\subsection{SWI-Prolog Semantic WEB library}
\label{sec:swi-sw}

SWI Prolog standard distribution contains library for RDF processing.  The library represents URI as a corresponding functor with atom argument. This structure can be constructed with a special form \texttt{<NS>:<ID>}, where \texttt{<NS>} is an abbreviation of a name space, and \texttt{<ID>} is identifier of an entity.  Library contains predicates for loading graphs from files and sites, store them in various text based and binary formats.

The library support queries for the graphs as a predicate and as SPARQL.  There is a basic query optimization.  For the subclass and subpropery relation, library realizes transitive closure, which can be used in the predicate queries.  [[what else ???]]

The library imported in LogTalk as object, that is an encapsulation of all the library predicates.  There is a little conflict of operation ``:'' between LogTalk and RDF library [[How to resolve]].

\subsection{Semantic Server ClioPatria}
\label{sec:clio-descr}
[[ClioPatria]]

\subsection{PSM representation}
\label{sec:blocks}

PSM is represented with \texttt{code\_block} objects.  The object have the following interface:
\begin{minted}{logtalk}
% protocol of block object.
\end{minted}

The \verb|code_block|--objects consist of source code string lines and other objects, including other code blocks. Each item is denoted with \verb|item/1| and its private database element \verb|item_/1|.  The type of the element is defined by outer functor of the argument, \emph{e.g.}, we define with \verb|attributes(L)| a list \verb|L| of attributes of a class.  The way of rendering the sources is implemented by subclassing the object and realizing \verb|render/1| and \verb|renderitem/2|.  The first argument of \verb|renderitem/2| is the \verb|item/1|--structure to be rendered, and the second one is the list of strings representing generated source code.  Elements of the code block can be \verb|append|ed, \verb|prepend|ed and \verb|remove|ed.  We specially disallow to insert \verb|item|s into the database, as it will make object and its database more complex.  Instead, programmer can add an \verb|item| being another code block, inserting elements of the sources in it.


\subsection{Programming LogTalk Methods}
\label{sec:lgt-methods}

LogTalk object consists of encapsulated predicates (methods), some of them can be defined as dynamic, implementing object state.  LogTalk as a macro package provides two kind of objects: static and dynamic.  Static objects is defined and instantiated during compilation, dynamic ones are created with \texttt{create\_object/4} usually at runtime.  Static parameterized objects can be considered as third way of instantiation.

Static object instances are used for defining configurations, scenarios, interfaces to input and output targets (streams, models), graph databases, and other global compile time known entities.  Dynamic objects are used in construction of PSM objects, currently, each instantiation is an entity of target programming language.  Parametrized objects are facade interfaces to other objects, e.g., input targets and graph databases.  These objects enables programmer to define recognition rules over set of structures provided it with parameters.  Parameterized objects should be stateless, in this case, LogTalk compiles it in statically executed code.

%%%%% Methods can be redefined during inheritance.  Sending to the redefined method is done with ``\texttt{\^\^}'' message to self.


[[Idea how to implement objects, methods, instantiations, references, calls]]

\section{Defining rules of transformation}
\label{sec:mda-rules}

Transformation process is organized as a scenario of connected transformational objects (in terms of LogTalk) \cite{tereh1}.  Scenario is programmed as a special object defining transformation by means of calling \verb|tr/N| rules.  Rules recognize structures in the input graph elements and constructs code blocks.

\begin{minted}{logtalk}
:- object(direct(_Package,_LocalProf,_CodeProf)).
:- public([tr/4,tr/3]).
:- protected([package/1, profiles/2, profile/1]).
package(Package):- parameter(1, Package).
profile(Profile):- parameter(2, Profile).
profile(Profile):- parameter(3, Profile).
profiles(L):-
    findall(Profile, ::profile(Profile), L).
tr(class, Class, ClassID):- ::package(Package),
    query(Package)::class(Name, ClassID),
    create_object(Class,
        [instantiates(class)],[],[]),
    create_object(Attributes,
        [instantiates(params)],[],[]),
    create_object(Methods,
        [instantiates(methodlist)],[],[]),
    Class::name(Name),
    forall(
        ::tr(attribute,Attribute,ClassID,_AttrID),
        Attributes::append(Attribute) ),
    forall(
        ::tr(method, Method, ClassID, _MethodID),
        Methods::append(Method) ),
    Class::attributes(Attributes),
    Class::methods(Methods).
tr(attribute, Attribute, ClassID, AttributeID):-
    ::package(Package),
    query(Package)::attribute(Name,ClassID,AttrID),
    create_object(Attribute,
        [instantiates(param)],[],[]),
    Attribute::name(Name).
tr(method, Method, ClassID, MethodID):-
    ::package(Package),
    query(Package)::method(Name,ClassID,MethodID),
    create_object(Method,
    [instantiates(method)],[],[]),
    Method::name(Name).
:- end_object.
\end{minted}

The previous listing uses static parameterized object \verb|query/1|, whose argument is a graph representing model under transformation.  This is a powerful LogTalk abstraction instrument, which reduces necessity of adapter object creation in dynamic memory.  The SPARQL is encapsulated in methods.

\begin{minted}{logtalk}
:- object(query(_XMI)).
:- protected(xmi/1).
:- public([class/2, attribute/3, method/3]).
xmi(XMI) :- parameter(1, XMI).
class(Name, ID):- ::xmi(XMI),
    XMI::rdf(ID,rdf:type,uml,'Class'),
    XMI::rdf(ID,rdfs:label, literal(Name)).
attribute(Name, ClassID, ID):-  ::xmi(XMI),
    XMI::graph(G),
    XMI::rdf(ClassID, G:ownedAttribute, ID),
    % XMI::rdf(ID, rdf:type, uml,'Property'),
    XMI::rdf(ID, rdfs:label, literal(Name)).
method(Name, ClassID, ID):- ::xmi(XMI),
    XMI::graph(G),
    XMI::rdf(ClassID, G:ownedOperation, ID),
    XMI::rdf(ID, rdfs:label, literal(Name)).
:- end_object.
\end{minted}

Procedure of source code generation is build using \verb|code_block|--objects (the idea was taken from \verb|llvmlite| library), which provide PSM representation:

\begin{minted}{logtalk}
:- object(code_block, specializes(root)).
:- public([append/1, prepend/1, clear/0,
   render/1, render_to/1, remove/1, item/1,
   items/1 ]).
:- dynamic([item_/1]). % elements of
:- private([item_/1]). % the code block
:- protected([renderitem/2, render_to/2]).

item(Item)   :- ::item_(Item).
items(Items) :- bagof(I, ::item(I), Items).
append(Item) :- ::assertz(item_(Item)).
prepend(Item):- ::asserta(item_(Item)).
remove(Item) :- ::retract(item_(Item)).
clear        :- ::retractall(item_(_)).
render(_)    :- writef::writef("ERROR: \
Implement render/1 by a subclass!\n"), fail.

render_to(Stream):- ::render(List),
    ::render_to(List, Stream).
render_to(List, Stream):-
    lists::is_list(List),!,
    forall(lists::member(X,List),
       ::render_to(X, Stream)).
render_to(X,_) :- write(X),nl.
renderitem(Object, String):-
    current_object(Object), !,
    Object::render(String).
renderitem(literal(Item), String):-!,
    atom_string(Item, String).
renderitem(Item, String):-
    root::iswritef(String, '%q', [Item]).
:- end_object.
\end{minted}


The following example shows rendering class for Python classes. It contains public methods for defining class elements.
\begin{minted}{logtalk}
:- object(class, specializes(code_block),
   imports([named])). % A category of named entities
:- public([classlist/1, methods/1, attributes/1]).
classlist(ClassList):- % List of base classes
    ::prepend(classlist(ClassList)).
attributes(Attributes):- % List of attributes
    ::prepend(attributes(Attributes)).
methods(MethodList):- % List of methods
    ::append(methods(MethodList)).

renderitem(Item, Result):- % Default
    ^^renderitem(Item, Result).
render(Result):- % Render the class
    ^^render(Name),
    ( ::item(classlist(List)) ->
      List::render(ClassList),
      root::iswritef(Signature,'class %w(%w):',
        [Name, ClassList]);
      root::iswritef(Signature,'class %w:',
        [Name]) ),
    root::indent, % add an indent
    ( ::item(attributes(Attributes))->
      Attributes::render(DefAttrList),
      root::iswritef(ConstructorDef,
        'def __init__(self, %w):',
        [DefAttrList]),
      root::indent,  % more indent
      Attributes::items(InstanceAttrs),
      findall(S, ( % initialize attributes
         lists::member(Attr, InstanceAttrs),
         Attr::item(name(AttrName)),
         root::iswritef(S, "self.%w=%w",
           [AttrName, AttrName])
         ), AttrAssigns),
        root::unindent,
        AttrList=[ConstructorDef|AttrAssigns];
        root::iswritef(ConstructorDef,
          'def __init__(self): ', []),
        root::indent,
        root::iswritef(Pass,'pass', []),
        root::unindent,
        AttrList=[ConstructorDef, Pass] ),
    ( ::item(methods(Methods))-> % if any ...
      Methods::render(MethodList);
      MethodList=[] ),
    lists::append(AttrList,MethodList,StringList),
    root::unindent, Result=[Signature|StringList].
:- end_object.
\end{minted}

\subsection{Categories}
\label{sec:cats-impl}

LogTalk categories is very useful way of implementing a common functionality among a set of entities.  For example, programming language objects have an identifier and, optionally, type description.  These properties are implemented as two categories.
\texttt{named}, and its child \texttt{namedtyped}.
\begin{minted}{logtalk}
:- category(named).
:- public([name/1, render/1]).
:- protected([renderitem/2]).

name(Name):- ::prepend(name(Name)).

renderitem(name(Name), String):-!,
    atom_string(Name, String).

render(String):-
    ::item(name(Name)),
    ::renderitem(name(Name), String).

:-end_category.
\end{minted}

The category implies interface of \texttt{code\_object} for the object being enriched with it.  The second example adds type to the object.

\begin{minted}{logtalk}
:- category(namedtyped, extends(named)).
:- public([type/1,render/2,separator_option/2,
   list_separator/1]).
:- protected([renderitem/2]).

type(Type):-
   ::append(type(Type)).

renderitem(Item, String):-
   ^^renderitem(Item, String),!.
renderitem(type(Type),String):-!,
   ::list_separator(Separator),
   writef::swritef(String, '%w%w', [Separator, Type]).

render(Middle, String):-
   ^^render(SName),
   (
     ::item(type(Type)) ->
     ::renderitem(type(Type), SType),
     string_concat(SName, Middle, _1),
     string_concat(_1, SType, String) ;
     SName = String
   ).

render(String):-
   ::render("", String).

list_separator(Separator):-
   ::separator_option(Name, Default),!,
   root::option(Name, Separator, Default).

:- end_category.
\end{minted}

Similarly lists .... [[(list of superclasses, variables,...)]]

In the same way, we can construct procedures for creating structures of databases and populating them with initial data.

% SO, IT IS TRANSFORMATION OF BUSINESS PROCESS MODELS (GRAPHICALLY SET) INTO FORMAL LANGUAGE, SUITABLE FOR AUTOMATED REASONING? HOW IS IT COMBINED WITH DATA FROM THE DATABASE? HOW THE DATA FROM THE DOCUMENT MANAGEMENT SYSTEM IS EXTRACTED INTO DATA SUITABLE FOR AUTOMATED REASONING?

% THE POINT IS:
% 1. HAVING DOCUMENT MANAGEMENT COMBINED WITH THE BUSINESS PROCESS MODELS
% 2. COMBINING DATA FROM DOCUMENT MANAGEMENT SYSTEMS WITH FORMAL DESCRIPTION OF BUSINESS PROCESSES, IN THE FORM SUITABLE FOR AUTOMATED PROCESSING
% 3a). HAVING THE SYSTEM THAT CHECKS IF THE WORK (CAPTURED BY DOCUMENT MANAGEMENT), IS DONE ACCORDING TO PROCEDURES (WRITTEN AS BUSINESS PROCESS MODELS AND FORMALIZED)),  FOR THE ISO STANDARDS COMPLIANCE PURPOSE
% 3b). HAVING THE SYSTEM THAT WILL, ACCORDING TO THE BUSINESS PROCESS MODELS ( THAT REPRESENT ISO PROCEDURES) AUTOMATICALLY CONSTRUCT SOFTWARE THAT WILL BE CREATED FOR THE NEEDS OF THE BUSINESS PROCESS SPECIFIED BY THE MODEL. THIS IS VERY CLOSE TO THE WEB SERVICES ORCHESTRATION AND BPEL-WS.

%\section{Example of conversion}

%(We have no time to implement it)

\section{Conclusion}

% The idea of formal description of the business process during transition of a medical institution for compliance to ISO 9001:2015 standard is considered in the paper.  Diagrams SysML, BPMN2.0, CMMN are proposed to be used for this purpose.  The description provides Computational Independent Model (CIM) of Model Driven Architecture
% (MDA) software development approach, and it is to be transformed in subsystems of Informational System (IS).

% CIM is being designed with visual editors, \emph{e.g.} Modelio \cite{modelio}, translated from their XMI to RDF and stored as ontology graphs as files or network resources.  MDA-transformation is represented and executed within Prolog programming environment LogTalk \cite{tereh1}, which provides us knowledge structuring, rich set of libraries and uniform well-known programming language for defining transformation rules.  The general scheme of transformation definition is presented.

[[Presented how to use LogTalk to represent knowledge]]

[[What we have better with our approach.]] [[About instrumentation allowing development a special cases of transformation for startups]]

[[Problems of absence programmer practice of Logtalk: what sources to study.]]

IS development tools is being tested in representation of bioinformatic tool Mothur as Rapidminer dataflow diagrams \cite{dataflow}.  The source data for transformation is the module specifications and UML Class Diagram, which organizes submodules in virtual class hierarchies.  The result is a Rapidminer plug-in, with each Mothur module being represented as a data block.

\section{Acknowledgements}
\label{sec:ack-descr}

The presented research results is distributed among three grants as follows: aspect of LOD data representation and integration is supported by Russian Science Foundation, logical inference combining various source models and object--oriented knowledge representation is supported by Russian Foundation of Basic Research, and the presented example of Rapidminer dataflow modules is being developed with support of grant of Irkutsk Scientific Center SB RAS.

\begin{thebibliography}{99}
\bibitem{techaudit} [[[A book about technical audit.]]]
\bibitem{Clio} \emph{Wielemaker,J.}, \emph{Beek,W.}, \emph{Hildebrand,M.}, \emph{Ossenbruggen,J.} ClioPatria: A SWI-Prolog Infrastructure for the Semantic Web, Semantic Web. vol. 7, no. 5, 2016, pp.~529-541. DOI:\url{10.3233/SW-150191}
\bibitem{modelio} Modelio Open Source -- UML and BPMN free modeling tool. URL:\url{https://www.modelio.org/}.
%Related research
\bibitem{raslan} \emph{Raslan, W.}, \emph{Sameh, A.} Accelerating High-Level SysML and SystemC SoC Designs, URL:\url{https://www.design-reuse.com/articles/17562/high-level-sysml-systemc-soc-designs.html}
\bibitem{natale} \emph{Natale,M.}, \emph{Perillo,D.}, \emph{Chirico,F.}, \emph{Sindico,A.}, \emph{Sangiovanni-Vincentelli,A.} A Model-based approach for the synthesis of software to firmware adapters for use with automatically generated components, Software \& Systems Modeling, February 2018,~Volume 17,~Issue~1,~pp.~11-–33
\bibitem{boute} \emph{Boutekkouk,F.}, \emph{Fartas,O.} Automatic generation of SysML diagrams from VHDL code, In Proceedings of the Symposium on Complex Systems and Intelligent Computing (CompSIC), Souk Ahras, Algeria, September 2015.
\bibitem{mish} \emph{Mischkalla,F.}, \emph{He,D.}, \emph{Mueller,W.}, \emph{Azcarate,F.}, \emph{Carballeda,M.} A Retargetable SysML-based Front-End for High-Level Synthesis, In: Proceedings of 2nd Workshop on Model Based Engineering for Embedded Systems Design (M-BED), Mrz. 2011
\bibitem{tom16} \emph{Hauswald,T.} Automatic Code Synthesis of UML/SysML State Machines for airborne Applications.  Bachelor Thesis. Hamburg Univeristy of Technology. August 15. 2016. 80~p.
\bibitem{sysmlpres} \emph{Friedenthal,S.}, \emph{Moore,A.}, \emph{Steiner,R.} OMG Systems Modeling Language (OMG SysML™) Tutorial. 2009. 132~p. \url{http://www.omgsysml.org/INCOSE-OMGSysML-Tutorial-Final-090901.pdf}
\bibitem{tereh1} \emph{Cherkashin,E.}, \emph{Larionov,A.} \emph{et al.} Logical programming and data mining as engine for MDA model transformation implementation. Procs of 36th International Convention on Information and Communication Technology, Electronics and Microelectronics (MIPRO). May 20--24, 2013, Opatija, Croatia, pp.~1029--1036.
\bibitem{digarch} Digital Archives
\bibitem{icist} ICIST
\end{thebibliography}



% \begin{thebibliography}{11}
% \bibitem{Bizer} \textbf{Ch.\,Bizer, T.\,Heath, T.\,Berners-Lee.} Linked Data -- The Story So Far. \emph{Semantic Web and Information Systems}. 2009. Vol. 5 (3). pp.~1--22.
% \bibitem{Capadisli} \textbf{S.\,Capadisli, A.\,Guy, R.\,Verborgh, C.\,Lange, S.\,Auer, T.\,Berners-Lee.} Decentralised Authoring, Annotations and Notifications for a Read-Write Web with dokieli, In: Cabot J., De Virgilio R., Torlone R. (eds) \emph{Web Engineering. ICWE 2017. Lecture Notes in Computer Science.} vol 10360. Springer, Cham. Preprint URL:\url{http://csarven.ca/dokieli-rww}, DOI:\url{10.1007/978-3-319-60131-1_33}.
% \bibitem{Cherk} \textbf{E.\,Cherkashin, I.\,Orlova.} Instrumental tools for construction of the digital archives of the documents based on Linked Data. \emph{Modern technologies, System analysis, Modeling.} 4(56) 2017 pp. 100-107 (in Russian) \href{http://stsam.irgups.ru/sites/default/files/articles\_pdf\_files/100-107.pdf}{doi:10.26731/1813-9108.2017.4(56).100-107}
% \bibitem{Kopay} \textbf{A.\,Kopaygorodsky.} Use of ontologies in semantic information systems. \emph{Ontology of Design.} vol.~4(14), 2014, pp.~78--89 (in Russian) %URL:\href{http://agora.guru.ru/scientific_journal/files/Ontology_Of_Designing_4_2014_opt1.pdf#page=79}{\ttfamily %http://agora.guru.ru/scientific\_journal/files/On\-tology\_Of\_Designing\_4\_2014\_opt1.pdf}
% \bibitem{stratego} \textbf{D.\,Annenkov, E.\,Cherkashin.} Generation Technique for Django MVC Web Framework Using the Stratego Transformation Language. \emph{Proc. of 36th International Convention on Information and Communication Technology, Electronics and Microelectronics (MIPRO).} May 20--24, 2013, Opatija, Croatia, 2013, pp.~1084--1087.
% \bibitem{tereh1} \textbf{E.\,Cherkashin, A.\,Larionov et al.} Logical programming and data mining as engine for MDA model transformation implementation. \emph{Procs of 36th International Convention on Information and Communication Technology, Electronics and Microelectronics (MIPRO).} May 20--24, 2013, Opatija, Croatia, pp.~1029--1036.
% \bibitem{MDA} \textbf{D.\,Frankel.} Model Driven Architecture: Applying MDA to Enterprise Computing. Wiley; 1 edition, 2003, 352 p.
% \bibitem{Clio} \textbf{J.\,Wielemaker, W.\,Beek, M.\,Hildebrand, J.\,Ossenbruggen.} ClioPatria: A SWI-Prolog Infrastructure for the Semantic Web, \emph{Semantic Web.} vol. 7, no. 5, 2016, pp.~529-541. DOI:\url{10.3233/SW-150191}
% \bibitem{atl} \textbf{F.\,Jouault, F.\,Allilaire, J.\,Bezivin, I.\,Kurtev.} Atl: A model transformation tool. \emph{Sci. Comput. Program.} 72(1--2), pp.~31--39 (2008)
% \bibitem{QVT} The MOF Query/View/Transformation Specification Version 1.1. URL:\url{http://www.omg.org/spec/QVT/1.1}
% \bibitem{nikita} \textbf{A.\,Berman, M.\,Grishchenko, N.\,Dorodnykh, O.\,Nikolaychuk, A.\,Yurin.} A model-driven approach and a tool to support creation of rule-based expert systems for industrial safety expertise. \emph{Proc. of the 12 th International Forum on Knowledge Asset Dynamics (IFKAD-2017)} -- Russia, St.\,Petersburg : Graduate School of 16 Management of St.\,Petersburg University.  2017.  P.~2034--2050.
% \bibitem{GT} \textbf{A.\,Belghiat, M.\,Bourahla.} UML Class Diagrams to OWL Ontologies: A Graph Transformation based Approach. \emph{International Journal of Computer Applications}. 41. pp.~41--46. 10.5120/5525-7566.
% \bibitem{azis}\textbf{Y.\,Rhazali, Y.\,Hadi, A.\,Mouloudi.} Model Transformation with ATL into MDA from CIM to PIM Structured through MVC. \emph{Procedia Computer Science 83} (2016) 1096–1101. URL:\url{https://doi.org/10.1016/j.procs.2016.04.229}
% \bibitem{Rhazali}
% \textbf{Y.\,Rhazali, Y.\,Hadi, I.\,Chana, M.\,Lahmer, A.\,Rhattoy.} A model
% transformation in model driven architecture from business model to web
% model. \emph{IAENG International Journal of Computer Science}, vol.~45(1), 2018, 104-117, URL:\url{http://www.iaeng.org/IJCS/issues_v45/issue_1/IJCS_45_1_16.pdf}.
% % The paper \ref{Rhazali} proposes a model  transformation  method  to  master  the  transformation
% % from  CIM  to  PIM  web-based  in  accordance  with  the  Model
% % Driven  Architecture  approach. CIM is represented mainly with State and Use case UML-Diagrams connected with ATL rules.

% \bibitem{Hamid}
% \textbf{B.\,Hamid, D.\,Weber.} Engineering secure systems: Models, patterns
% and empirical validation. \emph{Computers \& Security},  vol~77, 2018, p.~315-348.
% \href{https://www.sciencedirect.com/science/article/pii/S0167404818303043}{doi:10.1016/j.cose.2018.03.016}

% % In \ref{Hamid} an approach proposed for evaluation security aspects of distributed applications using modeling, MDA description and synthesis of the applications. A logical inference evaluation is carried out over the MDA synthesized logical security models.

% \bibitem{Zdun}
% \textbf{S.\,Tragatschnig, S.\,Stevanetic, U.\,Zdun.} \href{https://www.sciencedirect.com/science/article/abs/pii/S0950584916303251}{Supporting the
% evolution of event-driven service-oriented architectures using change
% patterns.} \emph{Information and Software Technology.} vol.~100, 2018, p.~133-146. \href{doi:10.1016/j.infsof.2018.04.005}{https://www.sciencedirect.com/science/article/abs/pii/S0950584916303251}


% % The paper \ref{Zdun} is considered a highly decoupled distributed event-driven application environment, whose design and functioning is dynamically controlled by its three-level DSL description and MDA transformations, which support change propagation.

% \bibitem{Malki}
% \textbf{B.\,Bouougada, D.\,Bouchiha, M.\,Malki} A framework for
% reengineering web applications into linked data based on MDA. Paper
% presented at the ACM International Conference Proceeding Series, 2015,
% 23-25-November-2015 doi:10.1145/2816839.2816880

% % In \ref{Malki} a practical approach implemented with four-level description of ATL transformations from HTML-page to a RDF structure (via stage of an MDA PIM), which represents HTML (LI,TABLE, etc.) data as LOD.

% \bibitem{uml2owl} UMLtoOWL: Converter from UML to OWL. URL: \url{http://www.sfu.ca/~dgasevic/projects/UMLtoOWL/}.
% \bibitem{Dama}
% \textbf{V.\,\v{S}tuikys, R.\,Dama\v{s}evi\v{c}ius.} Meta-program development as a
% model transformation process. 2013. doi:10.1007/978-1-4471-4126-6\_11
% % A wide overview of Western approaches to program transformation is given in \cite{Dama,Dama2}, the language PROMOL is suggested as well as its logical semantics. The book \cite{Dama}, together with John McCarthy's and Steve Russell's LISP technologies and Enn Tyugu's conceptual programming, covers the problem space history almost completely.

% \bibitem{Dama2}
% \textbf{V.\,\v{S}tuikys, R.\,Dama\v{s}evi\v{c}ius, A.\,Targamadze.} A model-driven
% view to meta-program development process. \emph{Information Technology and
% Control.} vol.~39(2), 2010, p.~89-99. URL:\url{http://itc.ktu.lt/index.php/ITC/article/download/12302/6838}
% \bibitem{odmprof} ODM UML profile for OWL. URL:\url{http://www.omg.org/spec/ODM/1.0/PDF/}.
% \bibitem{odnext} Ontology Domain Modeling example. URL:\url{https://thematix.com/tools/vom/}.
% \bibitem{odmvis} OWL UML Visualizer. URL:\url{http://owlgred.lumii.lv/}.
% \bibitem{wsdl} Web Services Description Language -- Wikipedia, the free encyclopedia.  URL:\url{https://en.wikipedia.org/wiki/Web_Services_Description_Language}
% \bibitem{wsbpel} Business Process Execution Language -- Wikipedia, the free encyclopedia. \url{https://en.wikipedia.org/wiki/Business_Process_Execution_Language}
% \bibitem{modelio} Modelio Open Source -- UML and BPMN free modeling tool. URL:\url{https://www.modelio.org/}.
% \bibitem{dataflow} \textbf{Johnston W.M., Hanna J.R.P., Millar R.J.} Advances in Dataflow Programming Languages.
%   \emph{ACM Computing Surveys}. -- 2004. -- Vol. 36. -- pp. 1--34.
%   2004.~--~Vol.~36.~--~P.~1--34.
% \bibitem{SWEB} Semantic WEB Software Engineering. URL:\url{http://www.webist.org/Documents/Previous\_Invited\_Speakers/2012/WEBIST2012\_Pan.pdf}. %URL:\url{https://www.iospress.nl/book/semantic-web-enabled-software-engineering/}.
% \bibitem{uml25} Unified Modeling Language, ver.~2.5 standard description. URL:\url{http://www.omg.org/spec/UML/2.5/PDF}



% \end{thebibliography}




\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "tgr-paper"
%%% End:
